name: Deploy to Kubernetes via ArgoCD

on:
    workflow_dispatch:
        inputs:
            environment:
                description: 'Environment to deploy'
                type: choice
                required: true
                default: 'dev'
                options:
                    - dev
            tag_version:
                description: 'Tag version (optional, auto-generated if empty)'
                type: string
                required: false
            node_version:
                description: 'Node.js version'
                type: choice
                required: true
                default: '20'
                options:
                    - '20'
    push:
        branches:
            - main
        paths:
            - 'packages/**'
            - 'Dockerfile'
            - '.github/workflows/deploy-to-k8s.yml'

env:
    AWS_REGION: ap-southeast-1
    GITOPS_REPO: TomJennyDev/devops

jobs:
    # ============================================
    # Job 1: Set Environment Variables
    # ============================================
    set-env:
        name: Set Environment
        runs-on: ubuntu-latest
        outputs:
            tag: ${{ steps.set-vars.outputs.tag }}
            env: ${{ steps.set-vars.outputs.env }}
            node_version: ${{ steps.set-vars.outputs.node_version }}
            overlay_path: ${{ steps.set-vars.outputs.overlay_path }}
        steps:
            - name: Set variables
              id: set-vars
              run: |
                  # Get short SHA for tagging
                  SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)

                  # Determine environment and tag (always use SHA)
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                      ENV="${{ github.event.inputs.environment }}"
                      NODE_VERSION="${{ github.event.inputs.node_version }}"
                      if [ -n "${{ github.event.inputs.tag_version }}" ]; then
                          TAG="${{ github.event.inputs.tag_version }}-${SHORT_SHA}"
                      else
                          TAG="${SHORT_SHA}"
                      fi
                  else
                      # Auto-trigger from main branch - deploy to DEV only
                      TAG="${SHORT_SHA}"
                      ENV="dev"
                      NODE_VERSION="20"
                  fi

                  OVERLAY_PATH="argocd/apps/flowise/overlays/${ENV}"

                  echo "tag=${TAG}" >> $GITHUB_OUTPUT
                  echo "env=${ENV}" >> $GITHUB_OUTPUT
                  echo "node_version=${NODE_VERSION}" >> $GITHUB_OUTPUT
                  echo "overlay_path=${OVERLAY_PATH}" >> $GITHUB_OUTPUT

                  echo "ğŸ·ï¸ Tag: ${TAG}"
                  echo "ğŸ”– SHA: ${{ github.sha }}"
                  echo "ğŸŒ Environment: ${ENV}"
                  echo "ğŸ“¦ Node Version: ${NODE_VERSION}"
                  echo "ğŸ“‚ Overlay Path: ${OVERLAY_PATH}"

    # ============================================
    # Job 2: Build and Push Server Image
    # ============================================
    build-server:
        name: Build Server Image
        needs: set-env
        runs-on: ubuntu-latest
        permissions:
            contents: read
            id-token: write
        outputs:
            image_uri: ${{ steps.image-uri.outputs.uri }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            # Configure AWS credentials
            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v2

            - name: Set image URI
              id: image-uri
              run: |
                  REGISTRY="${{ steps.login-ecr.outputs.registry }}"
                  IMAGE_URI="${REGISTRY}/flowise-server:${{ needs.set-env.outputs.tag }}"
                  echo "uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
                  echo "ğŸ“¦ Server Image: ${IMAGE_URI}"
                  echo "ğŸ·ï¸ Additional tags: latest, ${{ github.sha }}"

            - name: Build and push Server image
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./packages/server/Dockerfile
                  build-args: |
                      NODE_VERSION=${{ needs.set-env.outputs.node_version }}
                  platforms: linux/amd64
                  push: true
                  tags: |
                      ${{ steps.image-uri.outputs.uri }}
                      ${{ steps.login-ecr.outputs.registry }}/flowise-server:latest
                      ${{ steps.login-ecr.outputs.registry }}/flowise-server:${{ github.sha }}
                  cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/flowise-server:buildcache
                  cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/flowise-server:buildcache,mode=max

            # Get image digest for immutable reference
            - name: Get image digest
              id: get-digest
              env:
                  AWS_REGION: ${{ env.AWS_REGION }}
              run: |
                  echo "ğŸ” Getting image digest from ECR..."

                  DIGEST=$(aws ecr describe-images \
                      --repository-name flowise-server \
                      --image-ids imageTag=${{ needs.set-env.outputs.tag }} \
                      --region ${AWS_REGION} \
                      --query 'imageDetails[0].imageDigest' \
                      --output text)

                  echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
                  echo "âœ… Image Digest: ${DIGEST}"

    # ============================================
    # Job 3: Build and Push UI Image
    # ============================================
    build-ui:
        name: Build UI Image
        needs: set-env
        runs-on: ubuntu-latest
        permissions:
            contents: read
            id-token: write
        outputs:
            image_uri: ${{ steps.image-uri.outputs.uri }}
            image_digest: ${{ steps.get-digest.outputs.digest }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v2

            - name: Set image URI
              id: image-uri
              run: |
                  REGISTRY="${{ steps.login-ecr.outputs.registry }}"
                  IMAGE_URI="${REGISTRY}/flowise-ui:${{ needs.set-env.outputs.tag }}"
                  echo "uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
                  echo "ğŸ“¦ UI Image: ${IMAGE_URI}"
                  echo "ğŸ·ï¸ Additional tags: latest, ${{ github.sha }}"

            - name: Build and push UI image
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./packages/ui/Dockerfile
                  build-args: |
                      NODE_VERSION=${{ needs.set-env.outputs.node_version }}
                  platforms: linux/amd64
                  push: true
                  tags: |
                      ${{ steps.image-uri.outputs.uri }}
                      ${{ steps.login-ecr.outputs.registry }}/flowise-ui:latest
                      ${{ steps.login-ecr.outputs.registry }}/flowise-ui:${{ github.sha }}
                  cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/flowise-ui:buildcache
                  cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/flowise-ui:buildcache,mode=max

            # Get image digest for immutable reference
            - name: Get image digest
              id: get-digest
              env:
                  AWS_REGION: ${{ env.AWS_REGION }}
              run: |
                  echo "ğŸ” Getting image digest from ECR..."

                  DIGEST=$(aws ecr describe-images \
                      --repository-name flowise-ui \
                      --image-ids imageTag=${{ needs.set-env.outputs.tag }} \
                      --region ${AWS_REGION} \
                      --query 'imageDetails[0].imageDigest' \
                      --output text)

                  echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
                  echo "âœ… Image Digest: ${DIGEST}"

    # ============================================
    # Job 4: Update Kustomize and Trigger ArgoCD
    # ============================================
    update-gitops-and-deploy:
        name: Update GitOps & Trigger ArgoCD
        needs: [set-env, build-server, build-ui]
        runs-on: ubuntu-latest
        steps:
            # Checkout GitOps repository
            - name: Checkout GitOps repository
              uses: actions/checkout@v4
              with:
                  repository: ${{ env.GITOPS_REPO }}
                  token: ${{ secrets.GITOPS_TOKEN }}
                  path: gitops

            # Configure AWS credentials for digest lookup
            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v2

            # Install kustomize
            - name: Setup Kustomize
              uses: imranismail/setup-kustomize@v2

            # Update image tags with digest
            - name: Update images with digest in Kustomize
              run: |
                  cd gitops/${{ needs.set-env.outputs.overlay_path }}

                  TAG="${{ needs.set-env.outputs.tag }}"
                  REGISTRY="${{ steps.login-ecr.outputs.registry }}"
                  SERVER_DIGEST="${{ needs.build-server.outputs.image_digest }}"
                  UI_DIGEST="${{ needs.build-ui.outputs.image_digest }}"

                  echo "ğŸ“ Updating images with digest (immutable):"
                  echo "  Server Tag: ${TAG}"
                  echo "  Server Digest: ${SERVER_DIGEST}"
                  echo "  UI Tag: ${TAG}"
                  echo "  UI Digest: ${UI_DIGEST}"
                  echo ""

                  # Update with digest for immutable deployments
                  # Format: registry/image@sha256:digest
                  SERVER_IMAGE_WITH_DIGEST="372836560690.dkr.ecr.ap-southeast-1.amazonaws.com/flowise-server@${SERVER_DIGEST}"
                  UI_IMAGE_WITH_DIGEST="372836560690.dkr.ecr.ap-southeast-1.amazonaws.com/flowise-ui@${UI_DIGEST}"

                  echo "ğŸ” Final image references:"
                  echo "  Server: ${SERVER_IMAGE_WITH_DIGEST}"
                  echo "  UI: ${UI_IMAGE_WITH_DIGEST}"
                  echo ""

                  # Update kustomization with digest
                  kustomize edit set image flowise-server=${SERVER_IMAGE_WITH_DIGEST}
                  kustomize edit set image flowise-ui=${UI_IMAGE_WITH_DIGEST}

                  # Also update with tag for reference (comment)
                  sed -i "s|# Tag:.*|# Tag: ${TAG} (Digest: ${SERVER_DIGEST:0:12}...)|" kustomization.yaml || true

                  echo ""
                  echo "ğŸ”„ Adding timestamp annotation to force pod restart..."

                  # Create/update deployment patch with timestamp annotation
                  TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

                  cat > deployment-restart-patch.yaml <<EOF
                  apiVersion: apps/v1
                  kind: Deployment
                  metadata:
                    name: flowise-server
                  spec:
                    template:
                      metadata:
                        annotations:
                          kubectl.kubernetes.io/restartedAt: "${TIMESTAMP}"
                  ---
                  apiVersion: apps/v1
                  kind: Deployment
                  metadata:
                    name: flowise-ui
                  spec:
                    template:
                      metadata:
                        annotations:
                          kubectl.kubernetes.io/restartedAt: "${TIMESTAMP}"
                  EOF

                  # Add patch to kustomization if not already there
                  if ! grep -q "deployment-restart-patch.yaml" kustomization.yaml; then
                      # Add to patchesStrategicMerge section
                      if grep -q "patchesStrategicMerge:" kustomization.yaml; then
                          sed -i '/patchesStrategicMerge:/a\- deployment-restart-patch.yaml' kustomization.yaml
                      else
                          echo -e "\npatchesStrategicMerge:\n- deployment-restart-patch.yaml" >> kustomization.yaml
                      fi
                  fi

                  echo "âœ… Timestamp annotation added: ${TIMESTAMP}"
                  echo ""
                  echo "ğŸ“„ Updated kustomization.yaml:"
                  cat kustomization.yaml
                  echo ""
                  echo "ğŸ“„ Restart patch:"
                  cat deployment-restart-patch.yaml

            # Commit and push changes
            - name: Commit and push to GitOps repo
              run: |
                  cd gitops

                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

                  git add ${{ needs.set-env.outputs.overlay_path }}/kustomization.yaml
                  git add ${{ needs.set-env.outputs.overlay_path }}/deployment-restart-patch.yaml

                  if git diff --staged --quiet; then
                      echo "âš ï¸ No changes detected, skipping commit"
                      exit 0
                  fi

                  git commit -m "chore(${{ needs.set-env.outputs.env }}): update images to ${{ needs.set-env.outputs.tag }}"
                  git push origin main

                  echo "âœ… Changes pushed to GitOps repository"

            # Trigger ArgoCD sync
            - name: Install ArgoCD CLI
              run: |
                  curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
                  chmod +x argocd
                  sudo mv argocd /usr/local/bin/
                  argocd version --client

            - name: Trigger ArgoCD sync and wait
              env:
                  ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
                  ARGOCD_USERNAME: admin
                  ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
                  ENV: ${{ needs.set-env.outputs.env }}
              run: |
                  APP_NAME="flowise-${ENV}"

                  echo "ğŸ” Logging in to ArgoCD..."
                  argocd login ${ARGOCD_SERVER} \
                      --username ${ARGOCD_USERNAME} \
                      --password ${ARGOCD_PASSWORD} \
                      --grpc-web \
                      --insecure

                  echo "ğŸ”„ Triggering ArgoCD sync for: ${APP_NAME}"

                  # Refresh app to detect changes
                  argocd app get ${APP_NAME} --refresh --grpc-web > /dev/null || true

                  # Trigger sync
                  argocd app sync ${APP_NAME} \
                      --grpc-web \
                      --prune \
                      --force

                  echo ""
                  echo "â³ Waiting for deployment to complete..."

                  # Wait for healthy status
                  argocd app wait ${APP_NAME} \
                      --grpc-web \
                      --health \
                      --timeout 600

                  echo ""
                  echo "âœ… Deployment completed successfully!"

            # Get final status
            - name: Show deployment summary
              if: always()
              env:
                  ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
                  ARGOCD_USERNAME: admin
                  ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
                  ENV: ${{ needs.set-env.outputs.env }}
              run: |
                  APP_NAME="flowise-${ENV}"

                  # Re-login in case of session timeout
                  argocd login ${ARGOCD_SERVER} \
                      --username ${ARGOCD_USERNAME} \
                      --password ${ARGOCD_PASSWORD} \
                      --grpc-web \
                      --insecure > /dev/null 2>&1 || true

                  echo "ğŸ“Š Deployment Summary:"
                  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  argocd app get ${APP_NAME} --grpc-web || echo "Failed to get app status"

                  echo ""
                  echo "ğŸ“ Resource Status:"
                  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  argocd app resources ${APP_NAME} --grpc-web || echo "Failed to get resources"

    # ============================================
    # Job 5: Post-deployment Health Check
    # ============================================
    # health-check:
    #     name: Health Check
    #     needs: [set-env, update-gitops-and-deploy]
    #     runs-on: ubuntu-latest
    #     if: success()
    #     steps:
    #         - name: Wait for pods to stabilize
    #           run: sleep 60

    #         - name: Health check
    #           env:
    #               ENV: ${{ needs.set-env.outputs.env }}
    #           run: |
    #               if [ "${ENV}" = "production" ]; then
    #                   ENDPOINT="${{ secrets.PROD_ENDPOINT }}"
    #               elif [ "${ENV}" = "staging" ]; then
    #                   ENDPOINT="${{ secrets.STAGING_ENDPOINT }}"
    #               else
    #                   ENDPOINT="${{ secrets.DEV_ENDPOINT }}"
    #               fi

    #               echo "ğŸ” Health check endpoint: ${ENDPOINT}/api/v1/health"

    #               # Retry health check up to 10 times
    #               for i in {1..10}; do
    #                   if curl -f -s "${ENDPOINT}/api/v1/health"; then
    #                       echo "âœ… Health check passed!"
    #                       exit 0
    #                   fi
    #                   echo "â³ Attempt ${i}/10 failed, retrying in 10s..."
    #                   sleep 10
    #               done

    #               echo "âŒ Health check failed after 10 attempts"
    #               exit 1

    #         - name: Notify deployment success
    #           if: success()
    #           run: |
    #               echo "ğŸ‰ Deployment completed successfully!"
    #               echo "Environment: ${{ needs.set-env.outputs.env }}"
    #               echo "Tag: ${{ needs.set-env.outputs.tag }}"
